async function requestPayout(){
  if(!S.addr){ alert('Подключите кошелёк (Connect)'); return; }

  // Если есть контракт-майнер → пытаемся клеймить on-chain
  if (minerContract){
    try{
      await refreshPendingFromContract();
      const enough = pendingWei >= (minClaimWei || UNIT);
      if(!enough){
        alert('До минимального порога 100 BGB ещё не дотянули (или minClaim из контракта).');
        return;
      }
      const tx = await minerContract.claim();
      $('msg').textContent = 'Claim tx sent: '+tx.hash;
      pushLine(`CLAIM TX: ${tx.hash.slice(0,14)}…`,'sys');
      const rcpt = await tx.wait();
      $('msg').textContent = 'Claim confirmed in block '+rcpt.blockNumber;
      await refreshPendingFromContract();
      return;
    }catch(e){
      console.error(e);
      // если клейм не удался — падаем в твой старый режим (модалка)
    }
  }

  // Fallback: твоя прежняя модалка для ручной выплаты
  if(S.accrued<UNIT){ alert('Нужно минимум 100 BGB для запроса выплаты!'); return; }
  const pay=S.accrued-(S.accrued%UNIT), last=S.chain.at(-1);
  const payload={
    address:S.addr, session:S.session,
    amountBGB:(Number(pay)/1e18).toFixed(3), amountWei:pay.toString(),
    height:S.height, lastBlock:last?last.hash:null, bits:S.bits,
    ts:new Date().toISOString(),
    message:`BGB Claim Request\nAddress: ${S.addr}\nSession: ${S.session}\nAmount: ${(Number(pay)/1e18).toFixed(3)} BGB\nHeight: ${S.height}\nBits: 0x${S.bits.toString(16)}\nLast: ${last?last.hash:'-'}\nTime: ${new Date().toISOString()}`
  };
  $('claimText').textContent=JSON.stringify(payload,null,2);
  $('claim').style.display='flex';
}
