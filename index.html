<script>
// ====== BGB Miner (browser only) ======
// - Цепочка блоков (prev -> hash) на keccak256
// - GENESIS prev-хэш (твой) для первого блока
// - compact bits/target и ретаргет каждые N блоков
// - «живой» хэшрейт, мемпул, прогресс до 30 BGB
// - Claim: подпись + предпросмотр JSON (копирование/открыть в Telegram)

(() => {
  // >>> Если используешь WalletConnect, положи его UMD и задай провайдер в window.__bgb_provider
  // иначе провайдер возьмём из window.ethereum (MetaMask/Trust-injected)
  // Пример: const p = new ethers.BrowserProvider(window.__bgb_provider || window.ethereum);

  // === Константы UI/логики
  const KEY = 'bgb_miner_ui_v2';
  const GENESIS_PREV = '0xf49bd1cb89367c32e3e3814b66ce02a181043f63f9af3dc1e9b5686faf15742d'; // <- твой стартовый prev
  const UNIT = 30n * 10n**18n;              // 30 BGB в wei
  const BASE_RATE = 5n * 10n**16n;          // 0.05 BGB/сек — визуальная скорость
  const BLOCK_TARGET_TIME = 10;             // целевое время блока (сек)
  const RETARGET_INTERVAL = 20;             // пересчёт сложности каждые N блоков
  const MAX_VIEW = 200;                     // сколько последних блоков показывать в списке

  // === Состояние
  let st = {
    addr: null, running: false, lastMs: Date.now(),
    accrued: 0n, bits: 0x1f00ffff, height: 0,
    chain: [], session: rndHex(16)
  };
  let mp = { count: 0, fee: 0.0, size: 0 };
  let hrBase = Number(BASE_RATE/10n**14n)/100; // для «дрожания»
  let hrJitter = 0;
  let pendingClaim = null;

  // === Утилиты
  const $ = id => document.getElementById(id);
  function rndHex(n){const a=new Uint8Array(n);(crypto.getRandomValues?crypto.getRandomValues(a):a.fill(0));return Array.from(a,x=>x.toString(16).padStart(2,'0')).join('');}
  function fmt(big,dp=4){const d=10n**18n;const i=big/d;const f=(big%d).toString().padStart(18,'0').slice(0,dp);return `${i}.${f}`;}
  function save(){try{localStorage.setItem(KEY,JSON.stringify({...st,accrued:st.accrued.toString()}));}catch{}}
  function load(){try{const x=JSON.parse(localStorage.getItem(KEY)||'null');if(x){st=Object.assign(st,x);if(typeof st.accrued==='string')st.accrued=BigInt(st.accrued);}}catch{}}
  const k256 = s => ethers.keccak256(ethers.toUtf8Bytes(s));

  // bits <-> target (упрощённо)
  function compactToTarget(bits){const exp=(bits>>>24)&0xff;const mant=bits&0x007fffff;let t=BigInt(mant);const sh=8*(exp-3);return sh>=0?t*(1n<<BigInt(sh)):t/(1n<<BigInt(-sh));}
  function targetToCompact(t){let exp=3,n=BigInt(t);while(n>0x007fffffn){n>>=8n;exp++;}const mant=Number(n&0x007fffffn);return((exp&0xff)<<24)|mant;}
  const curTarget = () => compactToTarget(st.bits);

  // === Рендер
  function showHashrate(){
    hrJitter += (Math.random()-0.5)*0.1;
    hrJitter = Math.max(-0.5, Math.min(0.5, hrJitter));
    const hr = Math.max(0, hrBase * (1 + hrJitter/10));
    $('sm-hr') && ($('sm-hr').textContent = `${hr.toFixed(2)} BGB/s`);
  }
  function render(){
    if ($('sm-addr')) $('sm-addr').textContent = st.addr?`${st.addr.slice(0,6)}…${st.addr.slice(-4)}`:'—';
    if ($('sm-bits')) $('sm-bits').textContent = '0x'+st.bits.toString(16);
    if ($('sm-height')) $('sm-height').textContent = st.height;
    if ($('sm-target')) $('sm-target').textContent = '0x'+curTarget().toString(16).slice(0,16)+'…';
    if ($('sm-acc')) $('sm-acc').textContent = fmt(st.accrued,4);
    if ($('sm-last')) $('sm-last').textContent = st.height?st.chain.at(-1).hash.slice(0,10)+'…':'—';
    if ($('sm-retarget')) $('sm-retarget').textContent = RETARGET_INTERVAL - (st.height % RETARGET_INTERVAL || RETARGET_INTERVAL);

    const pct = Math.min(100, Number(st.accrued * 100n / UNIT));
    if ($('sm-bar')) $('sm-bar').style.width = pct + '%';

    // мемпул
    if ($('mp-count')) $('mp-count').textContent = mp.count;
    if ($('mp-fee'))   $('mp-fee').textContent   = mp.fee.toFixed(2);
    if ($('mp-size'))  $('mp-size').textContent  = mp.size;

    // цепочка
    if ($('sm-chain') && !$('sm-chain').hasAttribute('hidden')){
      $('sm-chain').innerHTML = st.chain.slice(-MAX_VIEW).map(b =>
        `<div>#${b.idx} t=${new Date(b.time*1000).toLocaleTimeString()} bits=0x${b.bits.toString(16)} nonce=${b.nonce}<br>${b.hash} ← ${b.prev}</div>`
      ).reverse().join('');
    }
    showHashrate();
  }

  // === Майнинг
  function mineBatch(){
    // prev: первый блок строим на твоём GENESIS_PREV
    const prev = st.height ? st.chain.at(-1).hash : GENESIS_PREV;
    const target = curTarget();
    const tries = 512;
    const nowSec = Math.floor(Date.now()/1000);

    for (let i=0;i<tries;i++){
      const nonce = rndHex(8);
      const header = JSON.stringify({ver:1,prev,time:nowSec,bits:st.bits,nonce,merkle:rndHex(16)});
      const h = k256(header);
      if (BigInt(h) <= target){
        const blk = { idx: st.height+1, time: nowSec, bits: st.bits, nonce, prev, hash: h };
        st.chain.push(blk); st.height = blk.idx;
        if (st.chain.length > MAX_VIEW) st.chain = st.chain.slice(-MAX_VIEW);
        $('sm-msg') && ($('sm-msg').textContent = `Mined block #${blk.idx}`);
        if (st.height % RETARGET_INTERVAL === 0) retarget();
        return true;
      }
    }
    return false;
  }

  function retarget(){
    if (st.height < RETARGET_INTERVAL) return;
    const from = st.chain.length - RETARGET_INTERVAL;
    const first = st.chain[from], last = st.chain.at(-1);
    const actual = Math.max(1, last.time - first.time);
    const span = BLOCK_TARGET_TIME * RETARGET_INTERVAL;

    const oldT = curTarget();
    let newT = oldT * BigInt(actual) / BigInt(span);
    const minT = oldT/4n, maxT = oldT*4n;
    if (newT < minT) newT = minT;
    if (newT > maxT) newT = maxT;
    st.bits = targetToCompact(newT);

    // бейдж diff (если есть в вёрстке)
    const ind = $('diff-ind');
    if (ind){
      ind.textContent = `diff: 0x${st.bits.toString(16)}`;
      ind.className = 'diff-badge ' + (newT < oldT ? 'diff-up' : (newT > oldT ? 'diff-down' : ''));
    }
  }

  function tick(){
    if (!st.running) return;
    const now = Date.now(), dt = now - st.lastMs;
    if (dt <= 0) return;

    st.accrued += BASE_RATE * BigInt(Math.floor(dt/1000));
    st.lastMs = now;

    // простой мемпул
    mp.count = Math.max(0, Math.round(mp.count + (Math.random()*6 - 3)));
    mp.fee   = Math.max(0.1, mp.fee + (Math.random()*0.2 - 0.1));
    mp.size  = Math.max(0, Math.round(mp.size + (Math.random()*8 - 4)));

    mineBatch();
    save(); render();
  }

  // === Обработчики кнопок
  window.smConnect = async function(){
    const injected = (window.__bgb_provider || window.ethereum);
    if (!injected){ alert('Установите MetaMask или откройте сайт в Trust Wallet DApp.'); return; }
    try{
      const p = new ethers.BrowserProvider(injected);
      const s = await p.getSigner();
      st.addr = await s.getAddress();
      save(); render();
    }catch{ alert('Не удалось подключить кошелёк'); }
  };
  window.smStart = function(){ st.running = true; st.lastMs = Date.now(); $('sm-msg') && ($('sm-msg').textContent='Mining…'); save(); render(); };
  window.smStop  = function(){ st.running = false; $('sm-msg') && ($('sm-msg').textContent='Paused'); save(); render(); };
  window.smReset = function(){ if(confirm('Сбросить локальные данные майнера?')){ st.accrued=0n; st.chain=[]; st.height=0; st.lastMs=Date.now(); st.bits=0x1f00ffff; $('sm-msg') && ($('sm-msg').textContent='Reset done'); save(); render(); } };
  window.smToggleChain = function(){ const el=$('sm-chain'); if(!el) return; if(el.hasAttribute('hidden')) el.removeAttribute('hidden'); else el.setAttribute('hidden',''); render(); };

  // === Claim с модальным предпросмотром
  window.smRequest = async function(){
    if (st.accrued < UNIT){ alert('Нужно ≥30 BGB'); return; }
    const injected = (window.__bgb_provider || window.ethereum);
    if (!injected){ alert('Подключите кошелёк'); return; }
    try{
      const p = new ethers.BrowserProvider(injected);
      const s = await p.getSigner();
      const addr = await s.getAddress();

      const payoutWei = st.accrued - (st.accrued % UNIT);
      const amountBGB = fmt(payoutWei, 4);
      const last = st.chain.at(-1);
      const payload = {
        address: addr, session: st.session, amountBGB,
        amountWei: payoutWei.toString(), height: st.height,
        lastBlock: last ? last.hash : null, bits: st.bits,
        ts: new Date().toISOString()
      };
      const msg =
`BGB Claim Request
Address: ${addr}
Session: ${st.session}
Amount: ${amountBGB} BGB
Height: ${st.height}
Bits: 0x${st.bits.toString(16)}
Last: ${last ? last.hash : '-'}
Time: ${payload.ts}`;

      const sig = await s.signMessage(msg);
      pendingClaim = { ...payload, signature: sig, message: msg };

      // если есть модалка (claim-modal/claim-json), покажем предпросмотр
      if ($('claim-json') && $('claim-modal')){
        $('claim-json').textContent = JSON.stringify(pendingClaim, null, 2);
        $('claim-modal').style.display = 'flex';
      }else{
        // fallback: просто копируем в буфер и открываем Telegram share
        try{ await navigator.clipboard.writeText(JSON.stringify(pendingClaim, null, 2)); }catch{}
        const share = `https://t.me/share/url?url=&text=${encodeURIComponent(msg+'\n\nSignature: '+sig)}`;
        window.open(share,'_blank','noopener,noreferrer');
      }
    }catch(e){ console.error(e); alert('Ошибка запроса'); }
  };
  window.copyClaim = async function(){ if(!pendingClaim) return; try{ await navigator.clipboard.writeText(JSON.stringify(pendingClaim,null,2)); }catch{} };
  window.sendClaim = function(){ if(!pendingClaim) return; const share=`https://t.me/share/url?url=&text=${encodeURIComponent(pendingClaim.message+'\n\nSignature: '+pendingClaim.signature)}`; window.open(share,'_blank','noopener,noreferrer'); };
  window.closeClaim = function(){ if($('claim-modal')) $('claim-modal').style.display='none'; };

  // === Инициализация
  load(); render(); setInterval(tick, 500);
})();
</script>
